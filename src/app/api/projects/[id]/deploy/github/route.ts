import { NextResponse } from "next/server";
import { eq, and, desc } from "drizzle-orm";
import { auth } from "@/lib/auth";
import { db } from "@/lib/db";
import { projects, buildOutputs } from "@/lib/db/schema";

const GITHUB_API = "https://api.github.com";

async function ghFetch(
  path: string,
  token: string,
  options: RequestInit = {},
) {
  const res = await fetch(`${GITHUB_API}${path}`, {
    ...options,
    headers: {
      Authorization: `Bearer ${token}`,
      Accept: "application/vnd.github+json",
      "Content-Type": "application/json",
      ...options.headers,
    },
  });
  return res;
}

export async function POST(
  req: Request,
  { params }: { params: Promise<{ id: string }> },
) {
  try {
    const session = await auth();
    if (!session?.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { id: projectId } = await params;
    const { token, repoName, isPrivate } = await req.json();

    if (!token || typeof token !== "string") {
      return NextResponse.json(
        { error: "GitHub personal access token is required" },
        { status: 400 },
      );
    }

    // Verify project ownership
    const project = await db.query.projects.findFirst({
      where: and(
        eq(projects.id, projectId),
        eq(projects.userId, session.user.id),
      ),
      columns: { id: true, name: true },
    });

    if (!project) {
      return NextResponse.json(
        { error: "Project not found" },
        { status: 404 },
      );
    }

    // Get latest complete build
    const output = await db.query.buildOutputs.findFirst({
      where: and(
        eq(buildOutputs.projectId, projectId),
        eq(buildOutputs.status, "complete"),
      ),
      orderBy: [desc(buildOutputs.createdAt)],
      columns: { files: true },
    });

    if (!output?.files || output.files.length === 0) {
      return NextResponse.json(
        { error: "No completed build found. Build your project first." },
        { status: 404 },
      );
    }

    const files = output.files as { path: string; content: string }[];

    const slug =
      repoName?.trim() ||
      project.name
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, "-")
        .replace(/^-|-$/g, "");

    // 1. Create the repository (with auto_init so we have a default branch)
    const createRes = await ghFetch("/user/repos", token, {
      method: "POST",
      body: JSON.stringify({
        name: slug,
        private: isPrivate ?? false,
        auto_init: true,
        description: `Generated by Calypso from project "${project.name}"`,
      }),
    });

    if (!createRes.ok) {
      const err = await createRes.json().catch(() => ({}));

      if (createRes.status === 401 || createRes.status === 403) {
        return NextResponse.json(
          {
            error:
              "Invalid GitHub token. Make sure it has the 'repo' scope.",
          },
          { status: 401 },
        );
      }

      if (createRes.status === 422) {
        const msg =
          err?.errors?.[0]?.message ?? err?.message ?? "Repository already exists.";
        return NextResponse.json({ error: msg }, { status: 422 });
      }

      return NextResponse.json(
        { error: err?.message ?? "Failed to create repository." },
        { status: 500 },
      );
    }

    const repo = await createRes.json();
    const owner = repo.owner.login;
    const repoFullName = repo.full_name;

    // 2. Get the default branch ref (main)
    const refRes = await ghFetch(
      `/repos/${repoFullName}/git/ref/heads/${repo.default_branch}`,
      token,
    );

    if (!refRes.ok) {
      return NextResponse.json(
        { error: "Failed to read repository. Please try again." },
        { status: 500 },
      );
    }

    const refData = await refRes.json();
    const parentCommitSha: string = refData.object.sha;

    // 3. Create blobs for every file
    const treeItems: { path: string; mode: string; type: string; sha: string }[] =
      [];

    for (const file of files) {
      const blobRes = await ghFetch(
        `/repos/${repoFullName}/git/blobs`,
        token,
        {
          method: "POST",
          body: JSON.stringify({
            content: file.content,
            encoding: "utf-8",
          }),
        },
      );

      if (!blobRes.ok) {
        console.error("Blob creation failed for", file.path);
        return NextResponse.json(
          { error: `Failed to upload file: ${file.path}` },
          { status: 500 },
        );
      }

      const blob = await blobRes.json();
      treeItems.push({
        path: file.path,
        mode: "100644",
        type: "blob",
        sha: blob.sha,
      });
    }

    // 4. Create a tree with all files
    const treeRes = await ghFetch(
      `/repos/${repoFullName}/git/trees`,
      token,
      {
        method: "POST",
        body: JSON.stringify({ tree: treeItems }),
      },
    );

    if (!treeRes.ok) {
      return NextResponse.json(
        { error: "Failed to create file tree." },
        { status: 500 },
      );
    }

    const tree = await treeRes.json();

    // 5. Create a commit
    const commitRes = await ghFetch(
      `/repos/${repoFullName}/git/commits`,
      token,
      {
        method: "POST",
        body: JSON.stringify({
          message: "Initial project files from Calypso",
          tree: tree.sha,
          parents: [parentCommitSha],
        }),
      },
    );

    if (!commitRes.ok) {
      return NextResponse.json(
        { error: "Failed to create commit." },
        { status: 500 },
      );
    }

    const commit = await commitRes.json();

    // 6. Update the default branch ref to point to the new commit
    const updateRefRes = await ghFetch(
      `/repos/${repoFullName}/git/refs/heads/${repo.default_branch}`,
      token,
      {
        method: "PATCH",
        body: JSON.stringify({ sha: commit.sha }),
      },
    );

    if (!updateRefRes.ok) {
      return NextResponse.json(
        { error: "Failed to update branch. The repo was created but files may be missing." },
        { status: 500 },
      );
    }

    return NextResponse.json({
      url: repo.html_url,
      fullName: repoFullName,
      owner,
      repoName: repo.name,
      isPrivate: repo.private,
    });
  } catch (error) {
    console.error("GitHub repo creation error:", error);
    return NextResponse.json(
      { error: "Something went wrong. Please try again." },
      { status: 500 },
    );
  }
}
